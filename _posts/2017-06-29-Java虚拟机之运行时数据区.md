---
layout: post
title: JVM之运行时数据区
date: 2017-06-28
categories: blog
tags: [java,JVM,Java虚拟机]
description: JVM内存管理机制中的运行时数据区。

---

# Java虚拟机之运行时数据区

>Java虚拟机在执行Java程序的过程中会将它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间。

> ## Java运行时数据区划分示意图

   ![Alt text](/img/JVM运行时数据区.PNG)

> ## 各区域说明

* #### 方法区
    方法区为所有线程共享，存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等。该区域不需要连续的内存，可以选择固定大小或者可扩展，还可以选择不实现垃圾收集。HotSpot虚拟机在垃圾收集上把GC分代收集扩展到了方法区，使用永久代来实现方法区，但方法区与永久代并不等价。当方法区无法满足内存分配需求时，其会抛出的异常类型为OOM(OutOfMemoryError)异常。
    
* #### 堆
    对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块，它可以处于不连续的内存空间中，只要逻辑上连续即可。在实现时，可以实现成固定大小的，也可以是扩展的。该区域被所有线程共享，在虚拟机启动时被创建。此区域唯一的目的就是存放对象实例，几乎所有的对象实例都在此分配内存。Java堆是垃圾收集器管理的主要区域，一般采用分代收集方法，所以Java堆可分为新生代和老年代。当堆内没有内存完成实例分配且堆也无法再扩展时，将抛出OOM异常。
    
* #### 虚拟机栈 
    虚拟机栈是线程私有的，其生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。该区域具有两种异常情况：若线程请求的栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；若虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，将抛出OOM异常。
* #### 本地方法栈

    本地方法栈与虚拟机栈所发挥的作用非常相似，其区别不过是虚拟机栈为虚拟机执行Java方法(即字节码)服务，而本地方法栈则为Native方法服务。其异常类型也与虚拟机栈一样。
    
* #### 程序计数器
    程序计数器是一块较小的内存区间，可以看作是当前线程所执行的字节码的行号指示器。该区域是线程私有的，每个线程都需要一个独立的程序计数器。此内存区域是唯一一个没有规定任何OOM异常情况的区域。
